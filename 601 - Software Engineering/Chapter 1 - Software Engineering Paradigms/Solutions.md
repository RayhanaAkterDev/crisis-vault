###### 1. What is software? #board_2019
> **Software** is a collection of programs, data, and instructions that enable a computer to perform specific tasks. It acts as an intermediary *(মধ্যস্থতাকারী)* between the hardware and the user, allowing the hardware to execute various functions. Software can be divided into two main types:
>  - **System Software**: Includes operating systems and utility programs that manage computer hardware and resources.    
>  -  **Application Software**: Includes programs that help users perform specific tasks, such as word processing or internet browsing.    

---

###### 2. What do you mean by software engineering? #board_2022 #board_2021 #board_2017 
> **Software engineering** is an engineering discipline that is concerned with all aspects of software production from the early stages of system specification through to maintaining the system after it has gone into use. In this definition, there are two key phrases:
> 1. **Engineering discipline**: Engineers make things work. They apply theories, methods, and tools where these are appropriate.
> 2. **All aspects of software production**: Software engineering is not just concerned with the technical processes of software development but also with managing people, understanding user needs, and ensuring quality throughout the software lifecycle.
> 
> **Write down the IEEE definition of software engineering.** #board_2020 #board_2018
> The IEEE (*Institute of Electrical and Electronics Engineers*) definition of software engineering:
> - The application of a systematic, disciplined, quantifiable *(পরিমাপযোগ্য)* approach to the development, operation and maintenance of software, that is, the application of engineering to software.
> -  The study of the approaches as in the above statement.

---

###### 3. State and explain some qualities that are used to access software. #board_2018  
> **Some qualities that are used to access software**:
> 1. **Functional suitability**: A set of attributes that bear on the existence of a set of function and their specified properties. The functions are those that satisfy stated or implied needs.
> 	- Suitability
> 	- Accuracy
> 	- Interoperability
> 	- Compliance
> 	-  Security
> 2. **Reliability**: A set of attributes that bear on the capability of software to maintain its level of performance under stated condition for a stated period of time.
> 	- Maturity
> 	- Fault tolerance
> 	- Recoverability
> 3. **Usability**: A set of attributes that bear on the effort needed for use, and on the individual assessment of such use by a stated or implies set of users.
> 	- Understandability
> 	- Learn ability 
> 	- Operability
> 4. **Efficiency**: A set of attributes that bear on the relationship between the level of performance of the software and the amount of resources used under stated conditions
> 	- Time behavior
> 	- Resource behavior

---

###### 4. Explain the attributes of quality software. #board_2021 #board_2019  #board_2017 
- Explain the attribute of a good software product. 
> **Attributes of a good software product**: There are 4 attributes of a good software –
> 1.  **Maintainability**: Software written in such a way so that it can evolve to meet the changing need of customers. This is a critical attribute because software change is an inevitable requirement of a changing business environment..
> 2. **Dependability**: A software must be trustworthy, reliable, safe, and secured. Use of the software should not be harmful to the customer in any way. Even at a system failure, a dependable software should not cause physical or economical damage. Also, malicious users should not be able to access or damage the system.
> 3. **Efficiency**: A software should be efficient in every way. The software should not make wasteful of system resources. Responsiveness should be there, and  the memory utilization should be minimum and also the process time is a consideration.
> 4. **Acceptability**: The software must be acceptable to the group of users for which it's designed for software should be understandable, reliable and compatible with other system they use.

---

###### 5. List out the key challenges facing software engineering and discuss those. #board_2022 #board_2020  
- Mention the key challenges facing four qualities that are used to access software. #board_2019 
> **Key challenges facing software engineering**:
> 1. **The heterogeneity challenge**: Increasingly, systems are required to operate as distributed systems across networks that include different types of computer and with different kinds of supports systems. The heterogeneity challenge is the challenge of developing techniques to build dependable software which is flexible enough to cope with this heterogeneity.
> 2. **Legacy System Integration**:They majority of software systems which are in use were developed many years ago yet they perform critical business functions. The legacy challenge is the challenge of maintaining and updating this software in such a way that excessive costs are avoided and essential business services continue to be delivered.
> 3.  **Adapting to Business and Social Change**: Software needs to evolve rapidly in response to changes in business goals, customer demands, technology trends, and social needs. The challenge lies in designing systems that are resilient, modular, and adaptable, enabling continuous updates and upgrades without causing disruptions.
> 4. **Security and Trust**: With the growing threat of cyber-attacks, ensuring that software is secure and trustworthy is a critical concern. This challenge involves developing methods for building secure systems, protecting user data, handling vulnerabilities proactively, and maintaining user confidence through privacy and integrity.
> 5. **Delivery Speed and Efficiency**: In today's fast-paced digital world, there is constant pressure to deliver high-quality software quickly. This challenge focuses on optimizing development processes through automation, agile practices, continuous integration/deployment, and minimizing time-to-market without sacrificing quality or stability.

---

###### 6. Discuss about the professional and ethical responsibilities of a software engineering. #board_2021 
> **The professional and ethical responsibilities of a software engineering**:
> 1. **Confidentiality**: Engineers should normally respect the confidentiality of their employers or clients irrespective of whether or not a formal confidentiality agreement has been signed.
> 2. **Competence**: Engineers should not misrepresent their level of competence. They should not knowingly accept work which is out with their competence.
> 3. **Work Cooperatively in Teams**: Software development is often done in teams. Engineers should respect others in the team, communicate clearly, and help when needed. Good teamwork improves project quality.
> 4. **Ensure Software Quality**: Engineers must write clean, reliable, and secure code. They should test the software properly and make sure it works well and meets the client’s needs.
> 5. **Follow Legal Rules and Licenses**: Engineers should obey software laws like copyright rules, software licenses, and data protection laws. They must not copy code from others without giving credit or using proper licenses.
> 6. **Take Responsibility for Their Work**: A good engineer does not blame others for mistakes. They take full responsibility for the software they create and are ready to fix any issues caused by it.
> 7. **Use Skills for Good Purposes**: Software engineers should use their knowledge to help society. They can make useful applications that solve real problems and avoid working on harmful or illegal projects.
> 8. **Respect Intellectual Property**: Engineers should not steal others’ ideas or code. They must follow rules when using open-source software and give proper credit to original creators.
> 9. **Computer Misuse**: Software engineers should not use their technical skills to misuse  other people's computers. Computer misuse can range from small issues on a employer's machine/ computer to very serious problems.

---

###### 7. Write down some characteristics of legacy software. #board_2021 
**Legacy software** is old and outdated software that is still in use, even though newer and better versions may exist.
> **Characteristics of legacy software**:
> 1. **Old Technology**: Legacy software is built using outdated programming languages, tools, or platforms that are no longer widely used.
> 2. **Difficult to Maintain**: It is often hard to fix bugs or make changes because the code is complex, poorly documented, or the original developers are no longer available.
> 3. **Lack of Documentation**: Many legacy systems have little or no proper documentation, which makes understanding and updating the software challenging.
> 4. **High Maintenance Cost**: Maintaining legacy software can be expensive due to the need for specialized skills, compatibility issues, or the risk of system failure.
> 5. **Limited Compatibility**: Legacy software may not work well with modern systems, devices, or applications, making integration difficult.
> 6. **Critical to Business**: Despite being old, many legacy systems are still important for business operations and cannot be easily replaced.
> 7. **Poor Security**: Older systems often have weak or outdated security features, making them more vulnerable to cyberattacks.
> 8. **Performance Issues**: Legacy software may run slowly or inefficiently compared to modern alternatives due to outdated design or hardware limitations.

---

###### 8. What is meant by software quality assurance? #board_2017 
> **Software Quality Assurance (SQA)** is the process of ensuring that software meets the required quality standards throughout the *Software Development Life Cycle* (SDLC). It is an ongoing activity that regularly checks if the software is functioning correctly, follows rules and guidelines, and is free from major errors.
> SQA includes activities like testing, code reviews, process improvement, and documentation to make sure the final product is reliable, efficient, and error-free.

---

###### 9. Write down the principles of agile process method. #board_2022 #board_2020 #board_2017    
> **The principles of agile process method**:
> 1. **Early and Continuous Delivery**: The highest priority is to satisfy the customer through the early and continuous delivery of valuable software.
> 2. **Welcoming Changing Requirements**: Even if requirements change late in development, Agile supports and accepts them to give the customer a better product.
> 3. **Frequent Delivery of Working Software**: Software is delivered in small parts frequently, usually in weeks, so that feedback can be taken early.
> 4. **Close Collaboration with Customers**: Business people and developers must work together daily throughout the project to ensure customer's needs.
> 5. **Motivated Team**: Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.
> 6. **Face-to-Face Communication**: The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
> 7. **Working Software**: Working software is the primary measure of progress, not just documents or plans.
> 8. **Sustainable Development**: Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.
> 9. **Continuous Attention to Technical Excellence and Good Design**: Clean code and proper design help in maintaining software quality and ease of future changes.
> 10. **Simplicity**: Do only what is needed. Avoid adding extra features or unnecessary work.
> 11. **Self-Organizing Teams**: Teams should make their own decisions about how to complete their work for better efficiency and creativity.
> 12. **Regular Reflection for Improvement**: The team should regularly review their performance and find ways to become more effective.

---

###### 10. State and explain **process maturity levels** of SEI's CMM. #board_2022 #board_2019  
> The **Software Engineering Institute (SEI)** introduced the **Capability Maturity Model (CMM)** to assess and improve the maturity of software development processes in organizations. The model defines **five maturity levels**, where each level represents a specific state of process capability and improvement.
> 
> **Process maturity levels of SEI's CMM**:
> 1. **Level 1 – Initial**: At this stage, processes are **ad hoc and chaotic**. software processes are unpredictable, poorly controlled, and reactive. There is no formal planning or defined process structure. Success heavily depends on individual effort and heroics, not on repeatable procedures. Projects often suffer from missed deadlines, cost overruns, and quality issues.
> 2. **Level 2 – Repeatable**: Basic project management practices are introduced. The organization starts to establish discipline in tracking cost, schedule, and functionality. Successful practices from previous projects are repeated in similar new projects. However, these practices are not yet standardized across the whole organization.
> 3. **Level 3 – Defined**: At this stage, all processes are clearly defined, documented, and standardized across the organization. There is a well-established process framework that is followed by all teams. Roles and responsibilities are clearly assigned, and there is an emphasis on training and process consistency. Tailoring guidelines may be used to adapt processes for specific needs.
> 4. **Level 4 – Managed**: Processes are now measured and controlled using quantitative data. The organization uses metrics to understand and control both software process and product quality. Performance becomes predictable and consistent, and project outcomes can be forecasted with reasonable accuracy.
> 5. **Level 5 – Optimizing**: This is the highest level of maturity, where the focus is on continuous process improvement. The organization proactively identifies weaknesses and adapts processes using quantitative feedback, innovation, and advanced tools. The goal is to prevent defects, reduce waste, and improve efficiency and quality over time.

---

###### 11. What is the difference between software engineering and system engineering? #board_2018 
> **The differences between software engineering and system engineering are given below:**

| **System Engineering**                                                                                                                               | **Software Engineering**                                                                                                                                                        |
| ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| It deals with the overall design and management of complex systems.                                                                                  | It deals with the design, development, and maintenance of software.                                                                                                             |
| Covers both hardware and software components.                                                                                                        | Focuses only on software components.                                                                                                                                            |
| To ensure the system as a whole works efficiently and meets requirements.                                                                            | To create reliable and efficient software products.                                                                                                                             |
| Involves hardware, software, people, processes, and technologies.                                                                                    | Involves only code, programs, and software systems.                                                                                                                             |
| Focuses on system integration, coordination, and overall architecture.                                                                               | Mainly focuses on programming, testing, and software design.                                                                                                                    |
| Starts from requirement gathering of the entire system.                                                                                              | Starts after the system requirements are defined.                                                                                                                               |
| Highly concerned about the user and domains                                                                                                          | Highly focus on implementing quality software.                                                                                                                                  |
| Software engineering applies the knowledge and theoretical understanding gained through computer science to building high-quality software products. | This technique of using knowledge from various branches of engineering and science to introduce technological innovations into the planning and development stages of a system. |
| In system engineering the overall objective of the system must be defined.                                                                           | Software engineering is concerned with practical problems of producing software.                                                                                                |

---

###### 12. Distinguish between **software engineering** and **computer science**. #board_2022 
> **The differences between software engineering and computer science are given below:**

| **Point of Difference** | **Software Engineering**                                                           | **Computer Science**                                                                |
| ----------------------- | ---------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| Definition              | Concerned with the practical application of engineering to build software systems. | Concerned with the theoretical study of computation and algorithms.                 |
| Goal                    | To develop high-quality, maintainable, and reliable software products.             | To gain deep understanding of computational processes and logic.                    |
| Nature                  | Practical and project-based, focuses on real-world software problems.              | Theoretical and research-based, focuses on solving abstract problems.               |
| Focus Area              | Emphasizes on designing, testing, maintaining software using engineering methods.  | Emphasizes on algorithms, data structures, automata theory, and computation models. |
| Core Activities         | Includes software development, version control, testing, deployment, etc.          | Includes problem-solving, complexity analysis, theory development, etc.             |
| Tools & Technologies    | Uses IDEs, version control systems, testing tools, SDLC models, etc.               | Uses mathematical models, simulations, proofs, etc.                                 |
| Project Orientation     | Highly team-oriented; involves collaboration, planning, and management.            | Often individual or research-based, especially in early stages.                     |
| End Product             | Functional software systems or applications.                                       | Theoretical results, concepts, and sometimes programming solutions.                 |
| Mathematical Use        | Uses mathematics for logic, testing, and reliability analysis.                     | Deeply rooted in discrete math, logic, and formal methods.                          |
| Career Roles            | Software Engineer, QA Engineer, System Architect, DevOps Engineer.                 | Computer Scientist, Researcher, Data Scientist, Algorithm Designer.                 |

---

###### 13. Discuss different types of prototyping. #board_2018 
> Prototyping is a key approach in software development where early versions of a system or its components are built to understand requirements, test functionalities, and gather user feedback. Based on the purpose and nature of the project, different types of prototyping methods are used. These are discussed below:
> 
> 1. **Throwaway Prototyping (Rapid Prototyping)**: In throwaway prototyping, a quick and temporary model of the software is built to understand unclear or incomplete requirements. This prototype is used mainly for demonstration and requirement gathering purposes. Once the feedback is collected, the prototype is discarded, and the final system is developed from scratch. It helps reduce misunderstandings early on, but the work done on the prototype is not reused in the final product.
> 2. **Evolutionary Prototyping**: In evolutionary prototyping, the prototype is not discarded but instead gradually refined based on user feedback. The system is built in a step-by-step manner, and new features are added or improved continuously until it becomes the final product. This approach is ideal for projects where requirements are expected to evolve over time. It ensures better alignment with user needs, but can become complex to manage as the system grows.
> 3. **Incremental Prototyping**: Incremental prototyping involves breaking the overall system into smaller modules and developing prototypes for each module independently. These module prototypes are then integrated to form the complete system. This approach allows developers to focus on one feature at a time and makes it easier to test and improve specific parts of the application. It is particularly useful for large-scale projects where different components can be developed in parallel.
> 4. **Extreme Prototyping**: Extreme prototyping is primarily used in web-based application development. This type of prototyping emphasizes rapid UI development and quick user feedback. It follows a structured three-phase approach to ensure that the user interface and interaction meet the desired requirements before full backend integration.
> 	1. **Phase 1: Static HTML Mockup**: The first phase involves creating a simple, static HTML mockup of the user interface. This mockup focuses purely on the visual aspects of the design and does not include any functionality or dynamic content.
> 	2. **Phase 2: Functional Prototype with Simulated Data**: The static mockup is converted into a functional prototype, where interactions are simulated, but no real data is processed. This gives users a preview of the app's behavior.
> 	3. **Phase 3: Backend Integration**: The prototype is integrated with a real backend, enabling live data processing and turning the prototype into a fully functional application for testing.
> 

---
  
###### 14. What software engineering process? #board_2016
> The **software engineering process** is a structured approach to software development aimed at producing high-quality software. It involves a series of stages, each focused on a specific aspect of software creation.
> 1. **Project Planning and Feasibility Study**: This phase involves assessing the project's scope, cost, timeline, and resources. Feasibility studies are conducted to determine whether the project is technically, financially, and operationally viable.
> 2. **Requirement Analysis**: In this phase, the requirements of the software are gathered from stakeholders and analyzed to understand what the software must do.
> 3. **System Design**: Based on the requirements, the system's architecture and components are designed, including the user interface, database, and software modules.
> 4. **Implementation (Coding)**: The actual code for the system is written, following design specifications and coding standards.
> 5. **Testing**: After coding, the software undergoes various tests (unit, integration, system) to identify and fix defects and ensure it meets the requirements.
> 6. **Deployment**: The software is deployed to users, installed, and configured in the production environment.
> 7. **Maintenance**: After deployment, the software is maintained by fixing issues, improving performance, and updating features based on user feedback.

----

###### 15. Write down the umbrella activities of software engineering. #board_2021 #board_2020 #board_2018     
> Umbrella activities in software engineering support the main development processes and ensure that the project is completed successfully. These activities are ongoing throughout the software development lifecycle and help maintain project quality, control, and progress.
> 
> The activities of umbrella activities are discussed below:
> 1. **Software Project Tracking and Control**: This activity involves monitoring and managing the progress of the software project to ensure that it stays on schedule, within budget, and meets project goals. It includes tracking milestones, progress reports, and adjusting plans as needed.
> 2. **Risk Management**: Risk management focuses on identifying, analyzing, and mitigating potential risks that could affect the success of the software project. It helps prevent major issues and ensures that risks are proactively handled to minimize their impact.
> 3. **Software Quality Assurance (SQA)**: SQA involves activities to ensure that the software meets the required quality standards. This includes planning and conducting reviews, audits, inspections, and testing to verify that the software is reliable, secure, and performs as expected.
> 4. **Formal Technical Reviews**: These reviews involve structured assessments of the software design, code, and other project artifacts. They are conducted by a team of professionals, helping to identify defects early, improve quality, and ensure that the software meets its requirements.
> 5. **Software Configuration Management**: Configuration management involves tracking and controlling changes in the software and its related documentation. This ensures proper version control, enables traceability of changes, and maintains consistency across different parts of the software.
> 6. **Document Preparation and Production**: Creating and maintaining thorough documentation is essential throughout the software development process. This includes documenting requirements, design decisions, code, and test results, ensuring that the software is maintainable and understandable in the future.
> 7. **Reusability Management**: Reusability management encourages the development of software components that can be reused across different projects or modules. This helps reduce development time and effort by leveraging existing, tested components.
> 8. **Measurement and Metrics**: This activity involves defining and collecting metrics related to software development. It helps track the quality of the software and the efficiency of the development process. Metrics such as defect density, code complexity, and test coverage are commonly used.
> 9. **Project Management**: Project management encompasses planning, organizing, and overseeing the execution of the software project. It ensures the project stays on track by managing resources, schedules, budgets, and stakeholder communication, facilitating the successful completion of the project.
> 10. **Verification and Validation (V&V)**: Verification and validation activities ensure that the software is developed according to specifications and fulfills user requirements. Verification checks if the software was built correctly (i.e., according to the design), while validation ensures the right product is built (i.e., meeting user needs and expectations).

![[umbrella-activity.webp]]

---

###### 16. Briefly describe each step of software development life cycle. #board_2016 
>

---

###### 17. Explain incremental software process model with merits and demerits. #board_2022 #board_2020 #board_2018 
>

---
